   %% FEA PROCESSING SUITE - STEP 2/4 - INTERPOLATE DISPLACEMENTS AND COMPUTE STRAINS
%   ----------------------------------------------------------------------
%   This program is used to interpolate element displacements into 2D
%   slices, inject noise, make masks, and compute strains

%% VERSION HISTORY
% CREATED 6/26/20 BY SS
% MODIFIED 12/22/20 BY SS
%   - converted to loading an entire simulation set with new file formats
%   - reworked to be a function that returns the strain maps for a given soi (slices of interest)
%   - added noise introduction as needed
% MODIFIED 12/23/20 BY SS
%   - turned back into a script. the function was slow and unreliable
% MODIFIED 12/24/20 BY SS
%   - added time estimation function
% MODIFIED 1/XX/20 by SS
%   - added separate processing for noisy displacements
% MODIFIED 4/26/20 BY SS
%   - generalized variable names, cleaned up code

%% PARAMETERS
% which model keyword to run, used to quickly switch between simulation sets
model = 'simple3';  
cache_path = 'FEA_cached\';

if strcmp(model,'defect1')
    % the parameter file that should be used, as generated by
    % FEA_GenerateSims. Should be in the FEA_cached folder
    param_file = 'FEA_defect_model_0.26-1.28_0.001-10';
    
    % interpolation & strain calculation parameters
    smoothing = 50;         % number of smoothing cycles
    im_size = 256;          % image size to create
    slices = 60;            % # of z-axis slices to create
    soi = 28:36;            % slices of interest, which slices to actually process
    n_soi = size(soi,2);    % # of slices of interest
    
    % set desired imaging plane
    % X Z Y plane - coronal slices (default)
    % Y Z X plane - sagittal slices
    % X Y Z plane - axial slices
    plane = 'XZY'; 
    
    % zooming in or out, default is 0.8 (slightly zoomed out to avoid
    % pixels touching the edge of the image
    % a good zoom-in value is 2.0 (twice as large)
    scale = 0.8;
    
    noise = 0.0061;         % noise to add to the image, leave empty for no noise
    noise_type = 'std';     % type of noise (standard deviation, linear, dB, etc)
    
    % should cached files be used?
    %   [a b c]
    %   a = displacement interpolation
    %   b = nominal strains
    %   c = noisy strains
    use_cache = [1 1 1];
    
    % the order of part priority for mask coverage
    % parts with higher priority take preference when masks overlap
    msk_order = [1 2 3];
    
    % which parts should have their masks merged for strain analysis
    msk_combine = {[1 2], [3]};
    
    % number of cycles used to erode hanging pixels from masks (5-8 is good)
    msk_cycles = 8;
    
    % if you just want to analyze/interpolate a single scan instead of the
    % entire set, this is a convenient variable to use. uncomment to enable
    %override_1 = [8];
    %override_2 = [8];
elseif strcmp(model,'intact')
    param_file = [];
    smoothing = 50;
    im_size = 256;
    
%     slices = 60;
%     soi = 28:36;
%     plane = 'XZY';
    
    slices = 30;
    soi = 12:20;
    plane = 'ZYX';
    scale = 2.0;
    
    n_soi = size(soi,2);
    %noise = [30 15 7 3 1 -1 -3 -7 -15 -30];
    noise = [0.0061];
    noise_type = 'std';
    use_cache = [0 0 0];
    msk_order = [1 2];
    msk_combine = {[1],[2]};
    msk_cycles = 3;
    root = 'C:\Users\Sameer\OneDrive - Rensselaer Polytechnic Institute\Documents\FEA\Hex_Mesh_Knee_Cartilage\9932809_00mo\smoothed\models - febio\';
    febfiles = {[root 'intact_model.feb']};
    logfiles = {[root 'intact_model.log']};
    n_pts_1 = 1;
    n_pts_2 = 1;
elseif strcmp(model,'defect2')
    param_file = 'FEA_defect_model_6-30_0.001-1000';
    smoothing = 50;         % number of smoothing cycles
    im_size = 256;          % image size to create
    slices = 60;            % # of slices to create
    soi = 28:36;            % slices of interest
    n_soi = size(soi,2);    % # of slices to actually use 
    % figure out which imaging plane we want to use
    % X Z Y plane - coronal slices (default)
    % Y Z X plane - sagittal slices
    % X Y Z plane - axial slices
    plane = 'XZY'; 
    noise = 0.0061;
    noise_type = 'std';
    use_cache = [1 1 1];              % use cached files, or rebuild from scratch? disp - strains - noisy strain
    msk_order = [1 2 3];
    msk_combine = {[1 2], [3]};
    msk_cycles = 8;
elseif strcmp(model,'defect3')
    param_file = 'FEA_defect_model_6-30_0.001-1000';
    smoothing = 50;         % number of smoothing cycles
    im_size = 256;          % image size to create
    slices = 30;            % # of slices to create
    soi = 12:20;
    n_soi = size(soi,2);    % # of slices to actually use
    % figure out which imaging plane we want to use
    % X Z Y plane - coronal slices (default)
    % Y Z X plane - sagittal slices
    % X Y Z plane - axial slices
    plane = 'ZYX'; 
    noise = [0.0061];             % noise to add to the image, leave empty for no noise
    noise_type = 'std';
    use_cache = [1 1 1];              % use cached files, or rebuild from scratch?
    msk_order = [1 2 3];
    msk_combine = {[1 2], [3]};
    scale = 2.0;
    msk_cycles = 8;
    %override_1 = [1:13];
    %override_2 = [1];
elseif strcmp(model,'simple')
    param_file = 'FEA_simple_model_0.26-1.28_0-0';
    %sim_set = 'FEA_simple_model_6-30_0-0';
    smoothing = 20;         % number of smoothing cycles
    im_size = 64;          % image size to create
    slices = 1;            % # of slices to create
    soi = 1;            % slices of interest
    n_soi = size(soi,2);    % # of slices to use
    % figure out which imaging plane we want to use
    % X Z Y plane - coronal slices (default)
    % Y Z X plane - sagittal slices
    % X Y Z plane - axial slices
    plane = 'XZY'; 
    %noise = [30 15 7 3 1 -1 -3 -7 -15 -30];             % noise to add to the image, leave empty for no noise
    noise = [0.0061];
    noise_type = 'std';             % noise to add to the image, leave empty for no noise
    use_cache = [1 1 1];              % use cached files, or rebuild from scratch?
    msk_order = [4 3 2 1];
    msk_combine = {[1 2 3 4];};
    msk_cycles = 8;
elseif strcmp(model,'simple2')
    param_file = 'FEA_simple_model2_0.26-1.28_0-0';
    smoothing = 50;         % number of smoothing cycles
    im_size = 128;          % image size to create
    slices = 1;            % # of slices to create
    soi = 1;            % slices of interest
    n_soi = size(soi,2);    % # of slices to use
    % figure out which imaging plane we want to use
    % X Z Y plane - coronal slices (default)
    % Y Z X plane - sagittal slices
    % X Y Z plane - axial slices
    plane = 'XZY'; 
    %noise = [30 15 7 3 1 -1 -3 -7 -15 -30];             % noise to add to the image, leave empty for no noise
    noise = [0.0061];
    noise_type = 'std';             % noise to add to the image, leave empty for no noise
    use_cache = [1 1 1];              % use cached files, or rebuild from scratch?
    msk_order = [4 5 2 3 1];
    msk_combine = {[1 2 3 4 5];};
    msk_cycles = 8;
    %override_1 = 1;
    %override_2 = 1;
elseif strcmp(model,'simple3')
    param_file = 'FEA_simple_model2_0.26-1.28_0-0';
    smoothing = 150;         % number of smoothing cycles
    im_size = 512;          % image size to create
    slices = 1;            % # of slices to create
    soi = 1;            % slices of interest
    n_soi = size(soi,2);    % # of slices to use
    % figure out which imaging plane we want to use
    % X Z Y plane - coronal slices (default)
    % Y Z X plane - sagittal slices
    % X Y Z plane - axial slices
    plane = 'XZY'; 
    %noise = [30 15 7 3 1 -1 -3 -7 -15 -30];             % noise to add to the image, leave empty for no noise
    noise = [0.0061];
    noise_type = 'std';             % noise to add to the image, leave empty for no noise
    use_cache = [1 1 1];              % use cached files, or rebuild from scratch?
    msk_order = [4 5 2 3 1];
    msk_combine = {[1 2 3 4 5];};
    msk_cycles = 8;
    %override_1 = 1;
    %override_2 = 1;
else
    disp('That simulation set has not been added yet!')
    return
end

%% LOAD FROM CACHE, SAVE AS NEEDED
% load the simulation set info
if ~isempty(param_file)
    load([cache_path param_file '.mat'],'febfiles','logfiles','n_pts_1','n_pts_2','range_var1','range_var2','range_var3','root');
else
    
end

% load the cached simulated results
int_vars = ['_' plane '_' num2str(im_size) 'px_'];
strain_vars = ['_' plane '_' num2str(im_size) 'px_' num2str(smoothing) '_cycles'];

n_file_1 = n_pts_1;
n_file_2 = n_pts_2;

n_noise = size(noise,2);
if ~exist('scale','var')
    scale = 0.8;
end

% easy set up for file override
if exist('override_1','var')
    if isempty(override_1)   
        n_process_1 = 1:n_file_1;
    else
        n_process_1 = override_1;
    end
else
    n_process_1 = 1:n_file_1;
end

if exist('override_2','var')
    if isempty(override_2)
        n_process_2 = 1:n_file_2;
    else
        n_process_2 = override_2;
    end
else
    n_process_2 = 1:n_file_2;
end
    

%% IMPORT DISPLACEMENTS
if ~exist('disps', 'var')
    % run the element optimizer, helps read the remaining files faster
    disp('Optimizing element file!');
    [~,~,n_ele,n_prt,ele_size,~] = FEA_FileOptimizer(febfiles{1,1},'feb');
    opt.n_ele = n_ele;
    opt.n_prt = n_prt;
    opt.ele_size = ele_size;
    
    % variables to store data, and keep track of which simulations have
    % been run successfully
    to_use = ones(n_file_1,n_file_2);
    disps = zeros(im_size,im_size,slices,3,n_file_1,n_file_2);
    dmsk = false(im_size,im_size,slices,opt.n_prt,n_file_1,n_file_2);
    img_info = struct([]);
    
    % used for time estimation
    run_times = [];
    
    % run through and interpolate all slices
    for i = n_process_1
        for j = n_process_2
            tic;
            disp(['Running file: ' extract_filename(febfiles{i,j})]);
            disp('--------------------------------------------------');
            
            % check if the interpolation results already exist
            savefile = [cache_path extract_filename(febfiles{i,j}) int_vars '_intslices.mat'];
            if exist(savefile,'file') && use_cache(1)
                load(savefile,'s_disp','s_dmsk','s_img_info','s_opt','s_febfile','s_logfile','s_dim','s_finish')
                disps(:,:,:,:,i,j) = s_disp;
                dmsk(:,:,:,:,i,j) = s_dmsk;
                img_info(i,j).px_size = s_img_info.px_size;
                img_info(i,j).n_slc = s_img_info.n_slc;
                img_info(i,j).slc_thick = s_img_info.slc_thick;
                img_info(i,j).n_prt = s_img_info.n_prt;
                opt = s_opt;
                to_use(i,j) = s_finish;
                
                disp('Loaded from cache!')
            % otherwise, interpolate the model results
            else
                % run the node optimizer every time, tells us how many nodes we have
                disp('Optimizing node file!');
                [n_node,n_step,~,~,~,finish] = FEA_FileOptimizer(logfiles{i,j},'log');
                opt.n_node = n_node;
                opt.n_step = n_step;

                % make sure the simulation terminated properly, skip it if it wasn't 
                to_use(i,j) = finish;
                if ~finish
                    disp(['WARNING: ' extract_filename(logfiles{i,j}) 10 'Did not terminate normally! Skipping it...']);
                else
                    % use node/element file caching, helps speed up reading in data
                    % enabled by default
                    cached.node = 1;
                    cached.ele = 1;
                    
                    % read in the data
                    [ele_conn, ele_parts, ele_disp, node_coor, ~, dim, opt] = FEA_ReadData2(febfiles{i,j},logfiles{i,j},cached,opt);
                    
                    % interpolate the elements/nodes into 2D slices
                    [disps(:,:,:,:,i,j),dmsk(:,:,:,:,i,j),img_temp] = FEA_Import4(ele_conn,ele_parts,ele_disp,node_coor,dim,opt,im_size,slices,soi,scale,plane,msk_order);
                    
                    % record interpolated image information
                    img_info(i,j).px_size = img_temp.px_size;
                    img_info(i,j).n_slc = img_temp.n_slc;
                    img_info(i,j).slc_thick = img_temp.slc_thick;
                    img_info(i,j).n_prt = img_temp.n_prt;
                    
                    % save the results of this interpolation (WILL OVERRIDE
                    % ANY PREVIOUSLY SAVED INTERPOLATION RESULTS!)
                    s_disp = disps(:,:,:,:,i,j);
                    s_dmsk = dmsk(:,:,:,:,i,j);
                    s_img_info = img_info(i,j);
                    s_opt = opt;
                    s_febfile = febfiles{i,j};
                    s_logfile = logfiles{i,j};
                    s_dim = dim;
                    s_finish = to_use(i,j);
                    save(savefile,'s_disp','s_dmsk','s_img_info','s_opt','s_febfile','s_logfile','s_dim','s_finish');
                    
                    % finish up
                    disp(['Saved: ' extract_filename(savefile)]);
                    disp(['---------------------------------------------' 10 'Finished running file!']); 
                end 
            end
            % compute estimated remaining time
            [msg,run_times] = estimate_time(run_times,i,j,0,n_file_1,n_file_2,1,[]);
            disp(msg);
        end
    end
    disp(10);
    disp('--------------------------------------------------');
    disp('  F I L E  P R O C E S S I N G  C O M P L E T E!  ');
    disp('--------------------------------------------------');
end


%% FIX MASK OVERLAP & CREATE CONTINUOUS ROIS TO ANALYZE
% often, the masks of each part in the simulation will overlap a bit,
% which must be removed before smoothing/strain calculation
if ~exist('msk','var')
    disp('Removing mask overlap...')
    n_roi = size(msk_combine,2);
    % the separated masks, one per part, with overlap removed
    msk = false(im_size,im_size,n_soi,opt.n_prt,n_file_1,n_file_2);
    % the merged rois, based on the masks. see 'msk_combine' variable
    msk_roi = false(im_size,im_size,n_soi,n_roi,n_file_1,n_file_2);
    
    % remove the overlap between the masks, and merge ROIs as needed
    parfor i = n_process_1
        for j = n_process_2
            [msk(:,:,:,:,i,j), msk_roi(:,:,:,:,i,j)] = FEA_SeparateMasks(dmsk(:,:,soi,:,i,j),msk_order,msk_combine,msk_cycles);
        end
    end
    
    % display masks of slices of interest, with each part highlighted
    for i = 1:n_prt
        figure, montage(permute((sum(msk(:,:,:,:,1,1),4)+msk(:,:,:,i,1,1)),[1 2 4 3 5 6])), colorbar, caxis('auto');
    end
    
end


%% PROCESS DISPLACEMENTS INTO STRAINS
if ~exist('strainP','var')
    % message to show what slices we're processing
    disp(['Computing strains for slices ' num2str(min(soi)) ' to ' num2str(max(soi))]);
    
    % holder for the strains, currently only looking at principal strains
    
    %strainGL = zeros(im_size,im_size,6,slices,n_file_2,n_file_2); % uncomment this to look at green-lagrange strains too. WARNING: this will increase required memory!
    strainP = zeros(im_size,im_size,3,n_soi,n_file_1,n_file_2);
    if n_noise > 0
        % strainGL_noise = zeros(im_size,im_size,6,n_soi,n_file_1,n_file_2,n_noise); % uncomment this to look at green-lagrange strains too. WARNING: this will increase required memory!
        strainP_noise = zeros(im_size,im_size,3,n_soi,n_file_1,n_file_2,n_noise);
    end
    

    run_times_s = [];
    
    % determine which disps to use in what order (interpolation direction =/= what you might consider X and Y and stuff)
    dir_name = ['X';'Y';'Z'];
    dir = zeros(1,3);
    for i = 1:3
        dir(i) = find(dir_name == plane(i));
    end
    
    % process the strains
    for j = n_process_1
        for k = n_process_2
            if to_use(j,k)
                tic;
                disp(['Running file: ' extract_filename(febfiles{j,k})]);
                disp('--------------------------------------------------');
                
                % check and load previously saved strains
                savefile = [cache_path extract_filename(febfiles{j,k}) strain_vars '_strains.mat'];
                if exist(savefile,'file') && use_cache(2)
                    load(savefile,'s_strainP','s_msk');
                    if size(s_strainP,4) == size(strainP,4)
                        strainP(:,:,:,:,j,k) = s_strainP;
                        msk(:,:,:,:,j,k) = s_msk;
                    else
                        strainP(:,:,:,:,j,k) = s_strainP(:,:,:,soi);
                        msk(:,:,:,:,j,k) = s_msk(:,:,soi,:);
                    end
                    disp('Loaded from cache!')
                    
                % otherwise, just run them
                else
                    for i = 1:n_soi
                        disp(['Processing slice ' num2str(soi(i)) '/' num2str(max(soi))])
                        tempGL = zeros(im_size,im_size,6,n_roi);
                        tempP = zeros(im_size,im_size,3,n_roi);
                        
                        % individually smooth rois and compute strains
                        % Note: roi =/= masks! Some masks are merged
                        % together to make a single roi! 
                        % See 'msk_combine' variable
                        for p = 1:n_roi
                            [tempGL(:,:,:,p), tempP(:,:,:,p), ~] = ProcessDisplacements(disps(:,:,soi(i),dir(1),j,k),disps(:,:,soi(i),dir(2),j,k),[],msk_roi(:,:,i,p,j,k),img_info(j,k).px_size,smoothing,1,[],false);
                        end
                        
                        % add all the rois together to make the full strain map
                        %strainGL(:,:,:,i,j,k) = sum(tempGL,4);         % uncomment this to also look at green-lagrange strains
                        strainP(:,:,:,i,j,k) = sum(tempP,4); 
                    end
                        
                    % save the results - add in strainGL to save those too!
                    % WARNING: re-running strains will override previously
                    % saved strains!
                    s_strainP = strainP(:,:,:,:,j,k);
                    s_msk = msk(:,:,:,:,j,k);
                    save(savefile,'s_strainP','s_msk'); 
                end
                
                % if we want to inject noise too, repeat this process
                if n_noise > 0
                    for n = 1:n_noise
                        
                        % check if there are previously saved results & load them
                        noise_vars = ['_' num2str(noise(n)) '_' noise_type '_SNR'];
                        savefile = [cache_path extract_filename(febfiles{j,k}) strain_vars  noise_vars '_strains.mat'];
                        if exist(savefile,'file') && use_cache(3)
                            load(savefile,'s_strainP_noise');
                            strainP_noise(:,:,:,:,j,k,n) = s_strainP_noise;
                            
                        % otherwise, re-run files
                        else
                            disp(['-----------SNR: ' num2str(noise(n)) '----------'])
                            % inject noise
                            noise_disp = awgn2(disps(:,:,soi,:,j,k),noise(n),noise_type);
                            
                            % process the slices
                            for i = 1:n_soi
                                disp(['Processing noisy slice ' num2str(soi(i)) '/' num2str(max(soi))])
                                tempGL = zeros(im_size,im_size,6,n_roi);
                                tempP = zeros(im_size,im_size,3,n_roi);
                                
                                for p = 1:n_roi
                                    [tempGL(:,:,:,p), tempP(:,:,:,p), ~] = ProcessDisplacements(noise_disp(:,:,i,dir(1)),noise_disp(:,:,i,dir(2)),[],msk_roi(:,:,i,p,j,k),img_info(j,k).px_size,smoothing,1,[],false);
                                end
                                %strainGL_noise(:,:,:,i,j,k,n) = sum(tempGL,4); % uncomment this to also look at green-lagrange strains
                                strainP_noise(:,:,:,i,j,k,n) = sum(tempP,4); 
                            end
                            
                            % save the file, be sure to add strainGL if you
                            % want to save those too!
                            s_strainP_noise = strainP_noise(:,:,:,:,j,k,n);
                            save(savefile,'s_strainP_noise');
                        end
                    end
                end
                % estimate completion time
                [msg,run_times_s] = estimate_time(run_times_s,j,k,0,n_file_1,n_file_2,1,[]);
                disp(msg);
            end
        end
    end
    
    disp('------------------------------------------------------');
    disp('  S T R A I N  P R O C E S S I N G  C O M P L E T E!  ');
    disp('------------------------------------------------------');
    
end

